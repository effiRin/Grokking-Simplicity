
<br>

# Chapter 4. 액션에서 계산 빼내기

<br>

## 문제의 코드
<br>

![image](https://user-images.githubusercontent.com/101503543/230698725-14183808-050b-4121-9692-234b9b02abd1.png)

<br>

- 장바구니에 담겨있는 제품의 금액 합계를 볼 수 있는 기능, 무료 배송이 계산, 세금 계산 등의 코드
- 그러나 지금 코드는 비즈니스 규칙을 테스트하기 어렵고, 재사용하기 어렵다.
- 이 코드는 계산이나 데이터는 없고 모든 코드가 액션이다.
- 이 코드를 어떻게 함수형 프로그래밍으로 해결할 수 있을지 알아보자.

<br>

## 함수에는 입력과 출력이 있다.

- 모든 함수는 입력과 출력이 있다.
- 입력은 함수가 계산을 하기 위한 외부 정보이다.
- 출력은 함수 밖으로 나오는 정보나 어떤 동작이다. 
- 함수를 부르는 이유는 결과가 필요하기 때문이다. 그리고 원하는 결과를 얻으려면 입력이 필요하다.

<br>

### 입력과 출력은 명시적이거나 암묵적일 수 있다.
- 명시적 입력 : 인자
- 암묵적 입력 : 인자 외 다른 입력
- 명시적 출력 : 리턴값
- 암묵적 출력 : 리턴값 외 다른 출력

<br>

### 함수에 암묵적 입력과 출력이 있으면 액션이 된다.
- 반대로 함수에서 암묵적 입력과 출력을 없애면 계산이 된다.
- 암묵적 입력은 함수의 인자로 바꾸고, 암묵적 출력은 함수의 리턴값으로 바꾼다.
- 함수형 프로그래머는 암묵적 입력과 출력을 '부수 효과'라고 부른다. (부수 효과는 함수가 하려는 주요 기능(리턴값을 계산하는 일)이 아니다.)

<br>
<br>

![image](https://user-images.githubusercontent.com/101503543/230698647-5424e2df-3dd7-43bc-865f-7a6b3ccb1a89.png)

<br>


## 테스트 재사용성은 입출력과 관련 있다.

### 코드 개선을 위한 제안

1. DOM 업데이트와 비즈니스 규칙은 분리되어야 한다.
    - DOM을 업데이트하는 일은 함수에서 어떤 정보가 나오는 것이기 때문에 출력이다.
    - 하지만 리턴값이 아니기 때문에 암묵적 출력이다.
    - 사용자가 정보를 볼 수 있어야 하므로 DOM 업데이트는 어디선가 해야 한다.
    - 암묵적 출력인 DOM 업데이트와 비즈니스 규칙을 분리하자고 제안

<br>

2. 전역변수가 없어야 한다.
    - 전역변수를 읽는 것은 암묵적 입력이고, 바꾸는 것은 암묵적 출력이다.
    - 암묵적 입력은 인자로 바꾸고 암묵적 출력은 리턴값으로 바꾸면 된다.

<br>

3. DOM을 사용할 수 있는 곳에서 실행된다고 가정하면 안 된다.
    - 우리가 만든 함수는 DOM을 직접 쓰고 있다.
    - 마찬가지로 이것은 암묵적 출력으로 함수의 리턴값으로 바꿔야 한다.

<br>
4. 함수가 결과값을 리턴해야 한다.
    - 암묵적인 출력 대신 명시적인 출력을 사용해야 한다.

<br>
<br>
<br>

## 액션에서 계산 빼내기


액션에서 계산을 빼내는 과정을 살펴보자.  
먼저 계산에 해당하는 코드를 분리한다. 그리고 입력값은 인자로 출력값은 리턴값으로 바꾼다.

<br>

![image](https://user-images.githubusercontent.com/101503543/230699229-a60b768b-196b-4c16-82ed-700292eb47ab.png)


- 빼낸 코드를 새로운 함수로 만들고 이름을 붙여줬다. 
- 원래 코드에서 빼낸 부분은 새로 만든 함수를 호출하도록 고쳤다.
바꿔가겠다.
- 참고로 방금 한 리팩토링은 **서브루틴 추출하기(extract subroutine**)라고 할 수 있다. 기존 코드에서 동작은 바뀌지 않는다.  
(리팩토링 : 코드를 고치면서 동작은 그대로 유지하는 것.)

<br>

- 하지만 새로 만든 함수는 아직 액션이기 때문에 계산으로 바꿔야 한다.
- 계산으로 바꾸려면 어떤 입력과 출력이 있는지 확인해야 한다.

<br>

- 여기에 있는 입력과 출력은 모두 암묵적이기 때문에 명시적인 입력과 출력으로 바꿔야 계산이 된다.

<br>

![image](https://user-images.githubusercontent.com/101503543/230699607-524a2543-25a6-44af-ac8e-04fbdf259520.png)

- 전역변숫값을 바꾸는 일은 함수에서 데이터가 나가는 일이기 때문에 출력이다.

- 전역변숫값을 읽는 일은 데이터가 함수 안으로 들어오는 일이기 때문에 입력이다.


- 출력은 모두 같은 전역변숫값을 바꾼다. 따라서 전역변수 대신 지역변수를 사용하고 지역변수값을 리턴하도록 고친다.

- 원래 함수는 새 함수의 리턴값을 받아 전역변수에 할당하도록 고친다.

<br>

![image](https://user-images.githubusercontent.com/101503543/230699768-7e7f5855-900f-48dc-96ba-df0f23c0a222.png)

- 또한 암묵적 입력을 함수 인자로 바꾸어 본다. cart라는 인자를 추가하고 함수 안에서 cart 인자를 사용하도록 고친다.

- 그러면 calc_total() 함수는 계산이다. 모든 입력은 인자이고 모든 출력은 리턴값이다.

- 함수를 하나 뺐지만, 이 작업으로 시스템의 동작이 달라지진 않았다.

<br>
<br>

- 마찬가지로 add_item_to_cart() 함수에서도 계산을 빼낼 수 있다. 

- 빼낸 add_item() 함수를 계산으로 바꿔보자. 먼저 암묵적 입력과 출력을 찾아야 한다.

```
function add_item(name, price) {
    shopping_cart.push({
        name: name,
        price: price
    });
}
```

- 해당 함수는 전역변수인 shopping_cart를 읽기 때문에 입력이다. 또 push() 함수로 전역변수인 배열을 바꾸는 것은 출력이다.

- 전역변수를 읽으면 함수 안으로 데이터가 들어오기 때문에 입력이다.  
전역배열을 바꾸면 함수 밖으로 데이터가 나가기 때문에 출력이다.

- 이 암묵적 입력과 출력을 인자와 리턴값으로 바꾼다.

<br>

![image](https://user-images.githubusercontent.com/101503543/230700166-700222e3-e456-4bab-9de9-192551fa0d04.png)

- 호출하는 쪽은 전역변수를 인자로 넘기도록 고친다. 암묵적인 입력을 인자로 바꿔 명시적인 입력이 되었다.

![image](https://user-images.githubusercontent.com/101503543/230700212-9f858279-2d62-420e-8e46-bc9274da71ec.png)

- push() 함수로 전역배열을 변경하는 암묵적 출력을 없애본다. 

- 이 값을 바꾸는 대신 복사본을 만들고 복사본에 추가해 리턴한다.  
  (자바스크립트에선 배열을 직접 복사하는 방법이 없어 .slice()메소드를 사용했다. 그 이유는 6장 참고)

- 그리고 호출하는 코드에선 리턴값을 받아 전역변수에 할당했다. 이제 암묵적 출력값이 리턴값으로 바뀌었다.

- 이처럼 어떤 값을 바꿀 때 그 값을 복사해서 바꾸는 방법은 불변성을 구현하는 방법 중 하나이다.
이 방법을 **'카피-온-라이트(copy-on-write**)'라고 한다. (6장 참고)

- 복사본을 만들어서 인자 cart 값을 변경하지 않아도 되었다. 만약 인자로 전달한 배열을 직접 변경한다면 그 함수는 계산일까? 계산이 아니라면 왜일까?


<br>
<br>


## 쉬는 시간

- 코드가 더 많아진 것 같은데 이게 맞나?  
일반적으로 더 적은 코드가 좋은 것은 맞지만, 시간이 지나면서 함수로 분리한 것에 장점을 얻을 수 있다. 코드를 테스트하기 쉬워졌고 재사용하기 좋아졌다.

- 함수형 프로그래밍의 장점이 이게 전부?  
아님. 책 뒷부분에 동시성이나 설계, 데이터 모델링 측면에서 좋은 점들을 설명할 것

- 다른 곳에서 쓰지 않더라도 계산으로 분리하는 것이 중요한가?  
물론. 함수형 프로그래밍의 목적 중에 어떤 것을 분리해서 더 작게 만들려고 하는 것도 있다. 작은 것은 테스트하기 쉽고, 재사용하기 쉽고 이해하기 쉽다.

- 계산으로 바꾼 함수 안에서 아직도 변수를 변경하고 있다. 함수형 프로그래밍에선 모든 것이 불변값이어야 한다고 들었는데 어떻게 설명할 건지?  
불변값은 생성된 다음 바뀌면 안되는 값이다. 하지만 생성할 때는 초기화가 필요하다. 만약 초깃값이 있어야 하는 배열이 필요하고 이후에 바꾸지 않는다고 해도 초깃값을 넣기 위해 시작 부분에 값을 배열에 넣어줘야 한다.  
지역변수를 변경하는 곳은 나중에 초기화할 값으로 새로 생성한다. 지역변수이므로 함수 밖에서는 접근 불가능하다. 그리고 초기화가 끝났다면 그 값은 리턴해야 한다. 이처럼 값이 바뀌지 않으려면 원칙이 필요한데 자세한 내용은 6장에서.

<br>
<br>


### 계산 추출을 단계별로 알아보기

1. 계산 코드를 찾아 빼낸다.
코드를 추출해 새로운 함수를 만들어 리팩토링한다. 새 함수에 인자가 필요한다면 추가한다. 원래 코드에서 빼낸 부분에 새 함수를 부르도록 바꾼다.

2. 새 함수에 암묵적 입력과 출력을 찾는다.  
암묵적 입력은 함수를 부르는 동안 결과에 영향을 줄 수 있는 것을 말한다. 암묵적 출력은 함수 호출의 결과로 영향을 받는 것을 말한다.  
함수 인자를 포함해 함수 밖에 있는 변수를 읽거나 데이터베이스에서 값을 가져오는 것은 입력이다.  
리턴값을 포함해 전역변수를 바꾸거나 공유 객체를 바꾸거나, 웹 요청을 보내는 것은 출력이다.

3. 암묵적 입력은 인자로, 암묵적 출력은 리턴값으로 바꾼다.
새로운 리턴값이 생겼다면 호출하는 코드에서 함수의 결과를 변수에 할당해야 할 수도 있다.   
여기서 인자와 리턴값은 바뀌지 않는 불변값이라는 것이 중요하다. 리턴값이 나중에 바뀐다면 암묵적 출력이다. 또 인자로 받은 값이 바뀔 수 있다면 암묵적 입력이다. (6장에서 불변 데이터에 대해 다루면서 이런 것을 어떻게 강제할 수 있는지 배우자.)

<br>
<br>

## 개선한 전체 코드 
![image](https://user-images.githubusercontent.com/101503543/230700665-882a6c0f-7371-4fae-9303-a7a8a500a195.png)

<br>
<br>

## 요점 정리
- 액션은 암묵적 입력 또는 출력을 가지고 있다.
- 계산의 정의에 따르면 계산은 암묵적 입력이나 출력이 없어야 한다.
- 공유 변수(전역변수 같은)는 일반적으로 암묵적 입력 또는 출력이 된다.
- 암묵적 입력은 인자로 바꿀 수 있다.
- 암묵적 출력은 리턴값으로 바꿀 수 있다.
- 함수형 원칙을 적용하면 액션은 줄어들고 계산은 늘어난다는 것을 확인했다.

<br>
